{% extends "base.html" %}
{% block title %}{{ title }}{% endblock %}
{% block body %}
<style>
    body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }

    body.proctoring-active {
        overflow: hidden;
    }

    body.proctoring-active #header,
    body.proctoring-active #footer,
    body.proctoring-active .navbar,
    body.proctoring-active .footer {
        display: none !important;
    }

    body.proctoring-active #proctoring-layout {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 9999 !important;
    }

    #startup-container {
        width: 100%;
        height: 100vh;
        display: block;
    }

    body.proctoring-active #startup-container {
        display: none !important;
    }

    #proctoring-layout {
        display: flex;
        flex-direction: row;
        width: 100vw;
        height: 100vh;
        position: fixed;
        top: 0;
        left: 0;
        background: white;
        z-index: 9999;
    }

    .iframe-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 10000;
        pointer-events: none;
        background: transparent;
    }

    .iframe-overlay.active {
        pointer-events: auto;
    }

    #dmoj-content-container {
        flex-grow: 1;
        height: 100%;
        position: relative;
    }

    #dmoj-contest-frame {
        width: 100%;
        height: 100%;
        border: none;
        background-color: white;
    }

    #proctoring-sidebar {
        width: 320px;
        flex-shrink: 0;
        background-color: #f8f9fa;
        border-left: 1px solid #dee2e6;
        transition: all 0.3s ease-in-out;
        position: relative;
        display: flex;
        flex-direction: column;
    }

    #proctoring-ui {
        padding: 1em;
    }

    #proctoring-sidebar.collapsed {
        width: 0;
        padding: 0;
        border-left: none;
    }

    #proctoring-sidebar.collapsed>* {
        visibility: hidden;
    }

    #toggle-sidebar-btn {
        position: absolute;
        top: 50%;
        left: 0;
        transform: translateY(-50%) translateX(-100%);
        width: 25px;
        height: 80px;
        border: 1px solid #dee2e6;
        border-right: none;
        background-color: #f8f9fa;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
        border-radius: 15px 0 0 15px;
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #555;
    }

    #proctoring-sidebar.collapsed #toggle-sidebar-btn {
        visibility: visible;
        transform: translateY(-50%) translateX(0) scaleX(-1);
        left: -25px;
        border-right: 1px solid #dee2e6;
        border-left: none;
        border-radius: 0 15px 15px 0;
    }

    body.proctoring-active {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }

    #fullscreen-exit-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10001;
        display: none;
        align-items: center;
        justify-content: center;
    }

    .modal-content {
        background: white;
        padding: 30px;
        border-radius: 10px;
        text-align: center;
        max-width: 500px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .modal-title {
        color: #dc3545;
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 15px;
    }

    .modal-message {
        color: #333;
        font-size: 16px;
        line-height: 1.5;
        margin-bottom: 25px;
    }

    .modal-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
    }

    .modal-btn {
        padding: 12px 25px;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .modal-btn-cancel {
        background: #6c757d;
        color: white;
    }

    .modal-btn-cancel:hover {
        background: #5a6268;
    }

    .modal-btn-leave {
        background: #dc3545;
        color: white;
    }

    .modal-btn-leave:hover {
        background: #c82333;
    }

    body.proctoring-active * {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
</style>

<!-- Include Sliding Window Video Buffer Module -->
{% include "contest/proctor/sliding_window_buffer.html" %}

<!-- Include Tab Switching Detection Module -->
{% include "contest/proctor/tab_switching_detection.html" %}

<!-- Startup container -->
<div id="startup-container">
    {% include "contest/proctor/proctoring_startup.html" %}
</div>

<div id="proctoring-layout" style="display: none">
    <div id="dmoj-content-container">
        <iframe id="dmoj-contest-frame" src="about:blank"></iframe>
        <div class="iframe-overlay" id="iframe-overlay"></div>
    </div>
    <div id="proctoring-sidebar">
        <button id="toggle-sidebar-btn" title="Toggle Proctoring Panel">â€¹</button>
        <div id="proctoring-ui">
            <h3 style="text-align: center; margin-top: 0; margin-bottom: 15px">
                Proctoring
            </h3>
            <div style="text-align: center; margin-bottom: 15px; padding: 8px; background-color: #f8f9fa; border-radius: 5px; border: 1px solid #dee2e6;">
                <strong>Contest:</strong> {{ contest.name }}
            </div>
            <video id="webcam" autoplay muted playsinline
                style="width: 100%; background: black; border-radius: 5px"></video>
            <canvas id="canvas" style="display: none"></canvas>
            <div id="status" style="margin-top: 10px; font-weight: bold; text-align: center">
                Initializing...
            </div>
            <div id="tab-switch-counter">
                <div class="counter-label">Tab Switches: <span id="tab-count" class="counter-value">0</span></div>
                <div class="counter-label">Time Outside: <span id="time-outside" class="counter-value">0s</span></div>
                <div class="monitoring-label">Monitoring Active</div>
            </div>
        </div>
    </div>
</div>

<!-- Fullscreen Exit Confirmation Modal -->
<div id="fullscreen-exit-modal">
    <div class="modal-content">
        <div class="modal-title">âš  Contest Security Warning</div>
        <div class="modal-message">
            You are attempting to exit fullscreen mode during the proctored contest.<br><br>
            <strong>This action will be logged as a violation.</strong><br><br>
            Do you want to:
        </div>
        <div class="modal-buttons">
            <button id="modal-cancel-btn" class="modal-btn modal-btn-cancel">
                Cancel & Stay in Contest
            </button>
            <button id="modal-leave-btn" class="modal-btn modal-btn-leave">
                Leave Contest
            </button>
        </div>
    </div>
</div>

<script>
    // Configuration
    window.proctoringConfig = {
        contestUrl: "{{ url('contest_view', contest.key) }}",
        contestName: "{{ contest.name }}",
        title: "{{ title }}",
        userId: "{{ user.id }}",
        username: "{{ user.username }}"
    };

    window.dmojData = {{ dmoj_data | tojson }};
    window.contestProctoredJoinUrl = "{{ url('contest_proctored_join', contest.key) }}";
    window.contestLeaveUrl = "{{ url('contest_leave', contest.key) }}";
    window.csrfToken = "{{ csrf_token }}";
</script>

<script>
    console.log("[MAIN] Script loaded");

    document.addEventListener("DOMContentLoaded", function () {
        console.log("[MAIN] DOM loaded - Starting initialization");

        // Configuration
        const API_BASE_URL = "http://127.0.0.1:8001";
        const DISABLE_BACKEND = window.dmojData && window.dmojData.disableBackend;

        // DOM elements
        const proctoringLayout = document.getElementById("proctoring-layout");
        const iframe = document.getElementById("dmoj-contest-frame");
        const sidebar = document.getElementById("proctoring-sidebar");
        const toggleBtn = document.getElementById("toggle-sidebar-btn");
        const video = document.getElementById("webcam");
        const canvas = document.getElementById("canvas");
        const statusDiv = document.getElementById("status");
        const startupContainer = document.getElementById("startup-container");
        const fullscreenExitModal = document.getElementById('fullscreen-exit-modal');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalLeaveBtn = document.getElementById('modal-leave-btn');

        // State variables
        let socket;
        let isProctoring = false;
        let mediaStream = null;
        let isShowingFullscreenModal = false;
        let isUserLeavingContest = false;
        let currentSessionId = null;
        let videoManager = null; // Will hold ProctoringVideoManager instance
        const ANALYSIS_INTERVAL_MS = 500;

        // Initialize Tab Switch Detector
        console.log("[MAIN] Initializing Tab Switch Detector");
        window.TabSwitchDetector.initialize({
            onTabSwitch: function(count, timeOutside) {
                console.log("[MAIN] Tab switch callback - Count:", count, "Time:", timeOutside);
                sendTabSwitchUpdate(count, timeOutside);
                if (statusDiv) {
                    statusDiv.textContent = 'WARNING: Tab switches detected: ' + count;
                }
            },
            onTimeUpdate: function(count, timeOutside) {
                console.log("[MAIN] Time update callback - Time:", timeOutside);
                sendTabSwitchUpdate(count, timeOutside);
            },
            onBackendUpdate: function(count, timeOutside) {
                console.log("[MAIN] Backend update callback");
                sendTabSwitchUpdate(count, timeOutside);
            }
        });

        // Message handler for contest iframe
        window.addEventListener('message', (event) => {
            if (event.origin !== window.location.origin || !event.data) return;

            if (event.data.proctoringPage) {
                console.log("[MAIN] Iframe navigated to:", event.data.proctoringPage);
            }

            if (event.data.proctoringAction === "end_session" || event.data.proctoringAction === "leave_contest") {
                console.log("[MAIN] Leave contest command received");
                stopProctoring();
                setTimeout(() => {
                    window.location.href = window.location.origin + "/contests/";
                }, 3000);
            }

            if (event.data.proctoringAction === "contest_violation") {
                console.log("[WARNING] Contest violation detected");
                statusDiv.textContent = 'VIOLATION: ' + (event.data.message || 'Rule violation detected');
            }
        });

        // Sidebar toggle
        if (toggleBtn) {
            toggleBtn.addEventListener("click", () => {
                sidebar.classList.toggle("collapsed");
            });
        }

        // Modal handlers
        if (modalCancelBtn) modalCancelBtn.addEventListener("click", handleModalCancel);
        if (modalLeaveBtn) modalLeaveBtn.addEventListener("click", handleModalLeave);

        // Main proctoring start handler
        window.handleStartProctoring = async function(data) {
            console.log("[MAIN] Starting proctoring");

            if (isProctoring) {
                console.log("[MAIN] Proctoring already active");
                return;
            }

            try {
                // Get media stream from startup
                if (!mediaStream && window.proctoringStartup) {
                    mediaStream = window.proctoringStartup.getMediaStream();
                }
                if (!mediaStream) throw new Error("Camera stream not available");

                // Join contest
                console.log("[MAIN] Joining contest...");
                const joinResponse = await fetch(window.contestProctoredJoinUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': window.csrfToken
                    },
                    body: 'csrfmiddlewaretoken=' + encodeURIComponent(window.csrfToken)
                });

                if (!joinResponse.ok) throw new Error("Failed to join contest");

                const joinData = await joinResponse.json();
                let contestUrl = data.config.contestUrl || window.proctoringConfig.contestUrl;
                if (joinData.success && joinData.contest_url) {
                    contestUrl = joinData.contest_url;
                }

                // Show proctoring layout
                startupContainer.style.display = 'none';
                proctoringLayout.style.display = 'flex';
                document.body.classList.add('proctoring-active');

                // Setup video
                video.srcObject = mediaStream;
                await video.play();

                isProctoring = true;

                // Enable security measures
                enableProctoringLock();
                
                // Setup iframe monitoring for tab switch detector
                window.TabSwitchDetector.setupIframeMonitoring(iframe);

                // Load contest
                iframe.src = contestUrl;
                iframe.onload = () => {
                    console.log("[MAIN] Contest loaded successfully");
                    statusDiv.textContent = 'Contest loaded. Proctoring active.';
                };

                // Initialize backend proctoring
                await initializeProctoringBackend();

                console.log("[MAIN] Proctoring started successfully");

            } catch (error) {
                console.error("[MAIN] Error starting proctoring:", error);
                alert("Failed to start proctoring: " + error.message);
                startupContainer.style.display = 'block';
                proctoringLayout.style.display = 'none';
                document.body.classList.remove('proctoring-active');
                isProctoring = false;
            }
        };

        // Backend initialization
        async function initializeProctoringBackend() {
            try {
                console.log("[MAIN] Initializing backend proctoring");
                
                const sessionResult = await startProctoringSession();
                if (!sessionResult.success) throw new Error('Failed to start session');

                currentSessionId = sessionResult.session_id;
                console.log("[MAIN] Session started:", currentSessionId);

                // Initialize WebSocket
                initWebSocket();
                
                // Initialize Video Manager
                console.log("[MAIN] Initializing Video Manager");
                videoManager = new window.ProctoringVideoManager(video, statusDiv, {
                    apiBaseUrl: API_BASE_URL,
                    bufferDuration: 20,
                    chunkInterval: 1000,
                    uploadTimeout: 30000,
                    maxRetries: 2,
                    retryDelay: 2000
                });

                await videoManager.initialize(mediaStream, {
                    userId: window.dmojData.userId,
                    username: window.dmojData.username,
                    contestName: window.dmojData.contestName
                });
                
                console.log("[MAIN] Video Manager initialized successfully");
                
                // Start frame analysis
                setInterval(sendFrameForAnalysis, ANALYSIS_INTERVAL_MS);
                
                console.log("[MAIN] Backend proctoring initialized successfully");
            } catch (error) {
                console.error("[MAIN] Backend init error:", error);
                statusDiv.textContent = 'Proctoring active (monitoring offline)';
            }
        }

        // Security functions
        function enableProctoringLock() {
            console.log("[MAIN] Enabling security lock");
            document.addEventListener('keydown', blockKeyboardShortcuts, true);
            document.addEventListener('contextmenu', blockContextMenu, true);
            window.addEventListener('beforeunload', preventPageExit);
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        function disableProctoringLock() {
            console.log("[MAIN] Disabling security lock");
            document.removeEventListener('keydown', blockKeyboardShortcuts, true);
            document.removeEventListener('contextmenu', blockContextMenu, true);
            window.removeEventListener('beforeunload', preventPageExit);
            document.removeEventListener('fullscreenchange', handleFullscreenChange);
            document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
            document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        function blockKeyboardShortcuts(event) {
            const blocked = ['F12', 'F5', 'F11', 'Escape', 'Tab'];
            if (blocked.includes(event.key) || event.ctrlKey || event.altKey) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
        }

        function blockContextMenu(event) {
            event.preventDefault();
            return false;
        }

        function preventPageExit(event) {
            event.preventDefault();
            event.returnValue = '';
            return '';
        }

        function handleFullscreenChange() {
            if (!isProctoring) return;
            if (!isFullscreen() && !isShowingFullscreenModal && !isUserLeavingContest) {
                showFullscreenExitModal();
            }
        }

        function isFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement ||
                document.mozFullScreenElement || document.msFullscreenElement);
        }

        function showFullscreenExitModal() {
            isShowingFullscreenModal = true;
            fullscreenExitModal.style.display = 'flex';
            statusDiv.textContent = "Fullscreen exit detected";
        }

        function hideFullscreenExitModal() {
            isShowingFullscreenModal = false;
            fullscreenExitModal.style.display = 'none';
        }

        function handleModalCancel() {
            hideFullscreenExitModal();
            requestFullscreen().catch(() => {
                setTimeout(() => {
                    if (!isFullscreen() && isProctoring) showFullscreenExitModal();
                }, 1000);
            });
        }

        function requestFullscreen() {
            const element = document.documentElement;
            const rfs = element.requestFullscreen || element.webkitRequestFullscreen ||
                element.mozRequestFullScreen || element.msRequestFullscreen;
            return rfs ? rfs.call(element) : Promise.reject();
        }

        function handleModalLeave() {
            isUserLeavingContest = true;
            hideFullscreenExitModal();
            if (window.contestLeaveUrl) {
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = window.contestLeaveUrl;
                const csrf = document.createElement('input');
                csrf.type = 'hidden';
                csrf.name = 'csrfmiddlewaretoken';
                csrf.value = window.csrfToken;
                form.appendChild(csrf);
                document.body.appendChild(form);
                stopProctoring();
                form.submit();
            } else {
                stopProctoring();
                window.location.href = window.location.origin + '/contests/';
            }
        }

        // Backend functions
        async function startProctoringSession() {
            if (DISABLE_BACKEND) {
                console.log("[MAIN] Backend disabled - local mode");
                return { success: true, session_id: 'local_' + Date.now(), status: 'local_only' };
            }
            try {
                const formData = new FormData();
                formData.append('dmoj_user_id', parseInt(window.dmojData.userId));
                formData.append('dmoj_user_name', window.dmojData.username || '');
                formData.append('dmoj_contest_name', window.dmojData.contestName || '');
                
                const response = await fetch(API_BASE_URL + '/start-session', { 
                    method: 'POST', 
                    body: formData 
                });
                
                if (!response.ok) throw new Error('HTTP ' + response.status);
                
                const result = await response.json();
                return { 
                    success: true, 
                    session_id: result.session_id, 
                    status: result.status 
                };
            } catch (error) {
                console.warn("[MAIN] Backend unavailable - using local mode");
                return { 
                    success: true, 
                    session_id: 'local_' + Date.now(), 
                    status: 'local_only' 
                };
            }
        }

        async function stopProctoringSession() {
            if (!currentSessionId || currentSessionId.startsWith('local_')) {
                currentSessionId = null;
                return;
            }
            try {
                const formData = new FormData();
                formData.append('dmoj_user_id', parseInt(window.dmojData.userId));
                await fetch(API_BASE_URL + '/stop-session', { method: 'POST', body: formData });
            } catch (error) {
                console.error('[MAIN] Stop session error:', error);
            }
            currentSessionId = null;
        }

        function sendTabSwitchUpdate(count, timeOutside) {
            if (DISABLE_BACKEND || !socket || socket.readyState !== WebSocket.OPEN || !currentSessionId) return;
            
            const message = {
                type: 'tab_switch',
                session_id: currentSessionId,
                count: count,
                time_outside: timeOutside,
                timestamp: new Date().toISOString()
            };
            
            socket.send(JSON.stringify(message));
        }

        function initWebSocket() {
            if (DISABLE_BACKEND || currentSessionId.startsWith('local_')) {
                console.log("[MAIN] WebSocket skipped - local mode");
                statusDiv.textContent = 'Proctoring active (local mode)';
                return;
            }
            
            const wsUrl = API_BASE_URL.replace('http', 'ws') + `/ws?session_id=${currentSessionId}`;
            console.log("[MAIN] Connecting to WebSocket:", wsUrl);
            socket = new WebSocket(wsUrl);
            
            socket.onopen = () => { 
                console.log('[MAIN] WebSocket connected');
                statusDiv.textContent = 'Connected. Proctoring started.'; 
            };
            
            socket.onclose = () => { 
                console.log('[MAIN] WebSocket closed');
                statusDiv.textContent = 'Proctoring active (offline)'; 
            };
            
            socket.onerror = (error) => { 
                console.error('[MAIN] WebSocket error:', error);
                statusDiv.textContent = 'Proctoring active (offline)'; 
            };
            
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('[MAIN] Server response:', data);
                
                // Handle tab switch acknowledgment
                if (data.type === 'tab_switch_ack') {
                    console.log('[MAIN] Tab switch acknowledged:', data);
                    return;
                }
                
                // Handle violation detection
                let violationMessage = 'Pattern detected';
                if (Array.isArray(data.violations) && data.violations.length > 0) {
                    violationMessage = data.violations[0]?.message || 'Pattern detected';
                    console.log('[MAIN] ðŸš¨ VIOLATION:', violationMessage);
                }
                
                statusDiv.textContent = data.is_compliant ? 'Status: Compliant' : `VIOLATION: ${violationMessage}`;
                
                // Trigger video upload if violation detected
                if (data.trigger_pattern_upload && videoManager) {
                    console.log('[MAIN] ðŸ“¹ Triggering violation video upload');
                    videoManager.triggerViolationUpload();
                }
            };
        }

        function sendFrameForAnalysis() {
            if (socket && socket.readyState === WebSocket.OPEN && video.videoWidth > 0) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                socket.send(canvas.toDataURL('image/jpeg', 0.5).split(',')[1]);
            }
        }

        function stopProctoring() {
            if (!isProctoring) return;
            
            console.log("[MAIN] Stopping proctoring");
            isProctoring = false;

            // Clean up tab switch detector
            window.TabSwitchDetector.sendFinalUpdate();
            window.TabSwitchDetector.reset();

            // Clean up video manager
            if (videoManager) {
                videoManager.cleanup();
                videoManager = null;
            }

            // Close WebSocket
            if (socket) socket.close();
            
            // Stop backend session
            stopProctoringSession();
            
            // Disable security measures
            disableProctoringLock();

            // Stop media stream
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            if (video.srcObject) video.srcObject = null;

            // Reset UI
            document.body.classList.remove('proctoring-active');
            proctoringLayout.style.display = "none";
            startupContainer.style.display = "block";
            
            console.log("[MAIN] Proctoring stopped successfully");
        }

        // Send final update before page unload
        window.addEventListener('beforeunload', () => {
            if (isProctoring) {
                window.TabSwitchDetector.sendFinalUpdate();
            }
        });

        console.log("[MAIN] Main system initialized and ready");
    });
</script>
{% endblock %}